name: Deploy to EC2 via SSM

on:
  push:
    branches:
      - master

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ap-south-1        # change to your region
  INSTANCE_ID: i-0561e40bf9b1cba8c   # or use a repo secret or lookup by tag
  APP_DIR: /home/ubuntu/myapp         # path on EC2 where repo lives
  BRANCH: main
  PM2_SERVICE_NAME: my-app-service      # pm2 process name or id

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code (optional, for artifacts / checks)
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::350276938231:role/ec2-deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Send SSM command to pull code and restart pm2
        id: ssm_send
        run: |
          set -e
          # Build the bash commands we want to run on EC2.
          # We pass them to AWS-RunShellScript via --parameters commands=[]
          #CMD="cd ${APP_DIR} && git fetch --all && git reset --hard origin/${BRANCH} || true && pm2 restart ${PM2_SERVICE_NAME}"
          CMD="cd ${APP_DIR} && git clone https://github.com/TestOrg889/acr-build-helloworld-node.git &&  cd acr-build-helloworld-node && node server.js &"
          echo "Running remote commands on ${INSTANCE_ID}: $CMD"
          aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "CI deploy from GitHub Actions" \
            --parameters commands=["$CMD"] \
            --region ${AWS_REGION} \
            --output json > send-output.json

          CMD_ID=$(jq -r '.Command.CommandId' send-output.json)
          echo "ssm-command-id=$CMD_ID" >> $GITHUB_OUTPUT

      - name: Wait for SSM command to complete and show output
        run: |
          set -e
          echo "Waiting for command ${{ steps.ssm_send.outputs.ssm-command-id }} to finish..."
          for i in {1..30}; do
            STATUS=$(aws ssm get-command-invocation --command-id "${{ steps.ssm_send.outputs.ssm-command-id }}" --instance-id "${{ env.INSTANCE_ID }}" --region "${{ env.AWS_REGION }}" --output json 2>/dev/null || echo "{}")
            invoc_status=$(echo "$STATUS" | jq -r '.Status // empty')
            echo "status: $invoc_status"
            if [[ "$invoc_status" == "Success" ]]; then
              echo "Command completed successfully"
              echo "Output:"
              echo "$STATUS" | jq -r '.StandardOutputContent'
              exit 0
            fi
            if [[ "$invoc_status" == "Failed" || "$invoc_status" == "TimedOut" || "$invoc_status" == "Cancelled" ]]; then
              echo "Command finished with status $invoc_status"
              echo "$STATUS" | jq -r '.StandardErrorContent'
              exit 1
            fi
            sleep 5
          done
          echo "Timed out waiting for SSM command"
          exit 1
